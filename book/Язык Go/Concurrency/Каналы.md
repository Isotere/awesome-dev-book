---
tags:
  - GoLang/Concurrency/Channels
---
По факту горутины могут  общаться через возможность "шарить" общую память. Доступ к памяти можно регулировать с помощью Mutex, Semaphore, Monitor. Но это сложный путь. 

Другой путь - взаимодействовать с другими горутинами через каналы (channels).

## Создание канала

```go
ch := make(chan string)
```

и эту переменную **ch** можно уже передавать в функцию, которые запускаются через горутины.

```go
func send(c chan string) {
	....
}
```

Каналы - двунаправленные. Можно и читать из них, можно писать в них.  Можно, при передаче в функцию, указать, что канал умет либо только читать либо только писать. 


```go

// Write only
func send(c chan<- string) {
	....
}

// Read only
func send(c <-chan string) {
	....
}
```

## Операции с каналами


```go
// Запись в канал
func send(c chan<- string) {
	c <- "Hello"
}

// Чтение из канала
func send(c <-chan string) {
	var s string
	s = <-c
	fmt.Println(s)
}
```

> Обратить внимание: при чтении из канала мы используем оператор присваивания (можно использовать и короткую запись объявления переменной := ). При записи в канал присваивание не используется. 

## Буферизованные и небуферизованные каналы

По умолчанию 

```go
c := make(chan string)
```

создает небуферизованный канал. Т.е. в канале одновременно может находиться не более одного "сообщения".  И перед тем, как записать туда следующее сообщение, необходимо чтобы получатель прочел существующее.

Для того, чтобы объявить буферизованный канал, необходимо указать его размер:


```go
c := make(chan string, 100)
```

## Аксиомы каналов

1. Запись в "nil"-канал - блокирует выполнение навсегда
2. Чтение из "nil"-канала - блокирует выполнение горутины навсегда
3. Запись в закрытый (closed) канал - вызывает **панику**
4. Чтение из закрытого канала - немедленно возвращает "нулевое" значение (зависит от типа)

```go
// nil-channel
var c chan int
```

Следствие из аксиом 3 и 4:
> Только "producer" может и должен закрывать канал. "consumer" никогда не должен этого делать!

