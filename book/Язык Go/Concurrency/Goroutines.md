---
tags:
  - GoLang/Concurrency/Goroutins
---

Горутины по факту не позволяют запускать задачи параллельно в прямом смысле. Можно ограничить кол-во используемых процессоров (ядер) до одного и горутины все равно запустятся и будет иллюзия параллельной работы.

Горутины позволяют запустить часть кода независимо от остальной части кода.

Функция main по факту также является горутиной. И если внутри нее запустить другие горутины и не использовать какой-либо механизм контроля или ожидания, то функция main завершится и вместе с ней будут завершены все остальные горутины, даже если они еще не закончили свою работу.

При всем этом горутины **НЕ являются** системными процессами или потоками (threads). Они значительно более легковесны. Горутины используют механизм потоков. И крутятся в рамках одного потока. Но если горутине надо выполнить долгоиграющую системную операцию (I/O или что-то еще), то на время ее выполнения горутина и сам поток "паркуются" в ожидание, а для других горутин создается либо берется из припаркованных другой поток. Когда припаркованная горутина заканчивает выполнение, она переходит в очередь ожидания на выполнение в текущую горутину, а "припаркованный" поток остается на "скамье ожидания", когда может опять понадобиться.

Есть также понятие "логических" CPU. На некоторое их кол-во разбивается реальный, физический процессор. И для каждого такого логического процессора создается своя очередь ожидания для горутин. И на каждом из них происходит такая вот ротация горутин на потоке.

В случае, когда на каком-то логическом процессоре очередь становится пустой - то она забирает половин ожидающих горутин из какой-либо другой очереди.

Если в локальных очередях уже нет горутин, то программа смотрит глобальную очередь, и если в ней есть ожидающие горутины - то берет их оттуда.

### Узнать кол-во доступных логических CPU:

```go
runtime.NumCPU() 
```

## Запуск GoRoutine

```go
package main

import "fmt"

func someFun(in int) {
	for i := 0; i <= in; i++ {
		fmt.Print(i)
	}
	fmt.Println()
	fmt.Println("Done!")
}

func main() {
	// обе запустятся одновременно
	go someFun(10)
	go someFun(15)
}
```

При запуске горутин в цикле с помощью замыкания - нужно быть осторожным, и не использовать внешние переменные цикла. Так как цикл может идти быстрее чем создаются горутины и то, что в итоге прочитает горутина может отличаться от ожидания. Лучше передавать как параметр замыкания.

```go
func main() {
	urls := []string{"addr1", "addr2", "addr3"}

	for _, url := range urls {
		go func(u string) {
			fmt.Println("Fetching ", u)
		}(url)
	}
}
```

## Ограничение кол-ва горутин в программе

Можно ограничить кол-во одновременно используемых ядер процессора с помощью переменной окружения GOMAXPROC

```sh
env GOMAXPROC=1 go run main.go
```

