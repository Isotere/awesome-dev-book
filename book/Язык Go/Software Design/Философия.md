## Производительность

- Если я не понимаю данные - я не понимаю задачу
- Все проблемы уникальны и специфичны для данных, с которыми они работают
- Трансформация данных - суть всех решаемых проблем. Каждая функция, метод и тд должны сфокусироваться на реализации специфичной трансформации данных, необходимой для решения проблемы
- Если данные меняются, то и задача меняется. Когда задача меняется, то и трансформация данных должна меняться вместе с ней
- Неуверенность в данных не повод для предсказаний и предположений, а указание ОСТАНОВИТЬСЯ и изучить проблему глубже
- Решение проблем, которых нет на данный момент - создает еще больше проблем
- Уменьшай, упрощай и сокращай  кол-во кода, необходимого для решения задачи. Делай меньше работы сокращая напрасный труд
- Код, который понятен и не скрывает цену выполнения может быть более ценен для понимания, отладки и оптимизации производительности
- Связывание данных вместе и написание кода с понятными и предсказуемыми паттернами доступа к ним будет наиболее производительным
- Изменение структуры данных может принести более значительное изменение производительности, чем просто изменение алгоритмов
- Эффективность достигается с помощью алгоритмов, но производительность достигается с помощью структуры и иерархии данных

## Интерфейсы и композиция

- Интерфейсы дают программе структуру
- Интерфейсы способствуют дизайну с помощью композиции
- Интерфейсы обеспечивают четкое разделение между компонентами
	- Стандартизация интерфейсов может установить четкие и последовательные ожидания
- Развязка (Decoupling) означает уменьшение зависимостей между компонентами и типами, которые они используют
	- Это обеспечивает корректность, качество и производительность
- Интерфейсы позволяют мне группировать конкретные типы по тому, что они делают
	- Объединяйте типы не по общей DNA, а по общему поведению
	- Все могут работать вместе, когда мы фокусируемся на том, что мы делаем, а не на том, кто мы есть
- Интерфейсы помогают моему коду отделить себя от изменений
	- Я должен сделать все возможное, чтобы понять, что может измениться, и использовать интерфейсы для разделения
	- Интерфейсы, содержащие более одного метода, требуют изменения по нескольким причинам
	- Неуверенность в переменах - это не разрешение на догадки, а указание ОСТАНОВИТЬСЯ и узнать больше
- Я должен различать код, который:
	- Защищает от мошенничества и защищает от несчастных случаев

## Конкурентность

- Приложение должно запускаться и завершать работу в полном объеме
	- Знайте, как и когда завершается каждая созданная мной горутина
	- Все горутины, которые я создаю, должны завершаться до того, как вернется main
	- Приложения должны быть способны отключаться по требованию, даже под нагрузкой, контролируемым образом
		- Я хочу прекратить принимать новые запросы и завершить те, которые у меня есть (сбросить нагрузку).
- Определите и контролируйте критические точки обратного давления, которые могут существовать в моем приложении
	- Каналы, мьютексы и атомарные функции могут создавать обратное давление, когда от горутин требуется ожидание
	- Небольшое обратное давление - это хорошо, это означает, что существует хороший баланс интересов
	- Сильное обратное давление - это плохо, это означает, что ситуация несбалансирована
	- Несбалансированное обратное давление приведет к:
		- Сбои внутри программного обеспечения и во всей платформе
		- Мое приложение может свернуться, взорваться или зависнуть
	- Измерение обратного давления - это способ оценить работоспособность приложения
- Rate Limit для предотвращения чрезмерного обратного давления внутри моего приложения
	- У каждой системы есть предел прочности, я должен знать, каков он для моего приложения
	- Приложения должны отклонять новые запросы как можно раньше, как только они будут перегружены
		- Не берите на себя больше работы, чем можно разумно выполнить за один раз
	- Используйте внешнюю систему ограничения нагрузки, когда это разумно и практично
- Используйте тайм-ауты, чтобы уменьшить обратное давление внутри моего приложения
	- Ни один запрос или задание не могут длиться вечно
	- Определите, как долго пользователи готовы ждать
	- Вызовы более высокого уровня должны сообщать вызовам более низкого уровня, как долго они должны выполняться
	- На верхнем уровне пользователь должен решить, как долго он готов ждать.
	- Используйте Context package
	- Функции, которые ожидают пользователи, должны иметь определенный Context
		- Эти функции следует select on <-ctx.Done(), в противном случае они были бы заблокированы на неопределенный срок
		- Устанавливайте тайм-аут для контекста только тогда, когда у меня есть веские основания ожидать, что выполнение функции ограничено реальным временем
		- Позвольте вышестоящему вызывающему устройству решать, когда контекст должен быть отменен
		- Отменять контекст всякий раз, когда пользователь отказывается от вызова или явно прерывает его
- Проектируйте приложения для:
	- Выявления проблем, когда они возникают
	- Предотвращения утечек
	- Возврата системы в нормальное состояние
