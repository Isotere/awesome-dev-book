# Trunk-Based Development

Это модель ветвления, в которой участники команды вносят частые небольшие изменения прямо в ветку `master`. За счёт того, что изменения небольшие и частые, такая модель склоняет разработчиков к использованию непрерывной интеграции, сборке, автотестам. Частые коммиты становятся обязанностью разработчиков, а нежелание поломать сборку заставляет писать код более внимательно. Такой подход гарантирует доступность последней рабочей версии кода по запросу.

Некоторые в рамках Trunk-Based Development всё же могут сделать выбор работать через pull-реквесты. Важное условие здесь в том, что feature-ветки в этом случае должны существовать недолго, и в одной ветке работает один человек.

Модель ветвления **Trunk-Based Development** подходит для опытных команд, на проектах с частыми релизами и налаженными процессами.

**Основные правила Trunk-Based Development**:

1. Короткий срок жизни веток (максимум 2 дня).
2. Коммиты и pull-реквесты делаются максимально часто.
3. За счёт частых и небольших изменений постоянно проводится интеграция продукта.
4. За счёт небольшого объёма изменений легко отследить ошибку.
5. За счет **Feature Flags** (включать и выключать функциональность в продукте флагами) можно деплоить код, который не готов.

**Преимущества Trunk-Based Development**:

- эффективна при работе в стартапе, например, для скорейшего создания MVP
- подразумевает быстрые итерации и процессы
- подразумевает высокую квалификацию разработчиков и доверие к ним

**Недостатки Trunk-Based Development**:

- модель неэффективна, если у разработчиков недостаточно квалификации или «кредита доверия»
- плохо работает в больших командах или в связке с Enterprise-продуктом


# Feature Branch Workflow

Основная идея модели **Feature Branch Workflow** заключается в том, что вся работа над новой функциональностью должна производиться в отдельной ветке, а не в ветке `master`. Это позволяет разработчикам трудиться над новыми фичами, не затрагивая основную базу кода, а также даёт несколько преимуществ. Во-первых, всегда есть рабочая версия кода в ветке `master`, а вместе с ней и возможность строить инфраструктуру непрерывной интеграции. Во-вторых, в рамках ветки для разработки новой функциональности удобно делать pull-реквесты, которые являются эффективным инструментом коммуникаций и работы над кодом. Например, в рамках pull-реквеста можно попросить помощи у коллег в решении какой-либо задачи.

Модель ветвления Feature Branch Workflow подходит для разнообразных проектов: и с фиксированной датой релиза и без, с CI/CD и без.

**Основные правила Feature Branch Workflow:**

1. Новая функция — новая ветка.
2. Merge и pull-реквесты — возможность для разработчиков вести обсуждение и делать ревью кода.
3. Может использоваться совместно с другими моделями.

**Преимущества Feature Branch Workflow**:

- простая модель, которую можно использовать как основу для создания собственных правил ветвления
- позволяет держать ветку `master` в чистоте, всегда имея последнюю рабочую версию кода
- универсальная модель для разных команд и разных циклов релиза

**Недостатки Feature Branch Workflow**:

- простота может создавать трудности при работе в больших командах

# Gitflow

Это модель ветвления, которая выстраивается вокруг релиза проекта. В ней используются две ветки для записи истории проекта. В ветке `master` хранится официальная история релиза, а `develop` служит в качестве интеграционной ветки для новых функций. Коммиты в ветку `master` помечаются номером версии (номером релиза).

Каждая новая функциональность должна разрабатываться в отдельной ветке, которые создаются не на основе `master`, a на основе `develop`. После завершения работы над новой функциональностью feature-ветка вливается назад в `develop`, в `master` новый код напрямую попадать **не должен**.

Когда в ветку `develop` уже слито достаточно нового кода для релиза (или подходит установленная дата предрелиза), от ветки `develop` создаётся ветка `release`. В ходе работы над веткой `release` новая функциональность уже не добавляется, а производится только исправление багов, создание документации и решение других задач, связанных с релизом. Когда всё готово, ветка `release` сливается в `master`, и ей присваивается тег с версией. Также она должна быть слита обратно в ветку `develop`, в которой с момента создания ветки релиза могли добавляться изменения.

Когда релиз готов к отправке, он сливается в `master` и `develop`, а ветка релиза удаляется. Важно влить её обратно в `develop`, поскольку в ветку `release` могут быть добавлены критические обновления, доступность которых необходима для новых функций.

Модель ветвления **Gitflow** хорошо показывает себя, когда работа ведётся с большим количеством распределённых команд разной квалификации. **Gitflow** подходит для «традиционной модели релизов», в фиксированные по времени даты.

**Основные правила Gitflow:**

1. Из `master` создаётся ветка `develop`.
2. Из `develop` создаются ветки `feature`.
3. Когда разработка новой функциональности завершена, она объединяется с веткой `develop`.
4. Из `develop` создаётся ветка `release`.
5. Когда ветка релиза готова, она объединяется с `develop` и `master`.
6. Если в `master` обнаружена проблема, из неё создаётся ветка `hotfix`.
7. Как только исправление на ветке `hotfix` завершено, она объединяется с `develop` и `master`.

**Преимущества Gitflow**:

- модель хорошо подходит для работы больших распределённых команд
- модель эффективна при работе с junior-разработчиками — большое количество итераций до отправки кода в релиз

**Недостатки Gitflow**:

- модель достаточно медленная, поэтому получение MVP, коммуникация сотрудников и организация процессов будут происходить неэффективно как в стартапе, так и в небольшой команде


